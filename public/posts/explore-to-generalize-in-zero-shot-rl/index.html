<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>ExpGen: Explore to Generalize in Zero-Shot RL | üß† RL Journal Club</title>
<meta name="keywords" content="exploration, generalization, zero-shot, ensemble, entropy, IMPALA, PPO, IDAAC, procgen, NeurIPS, 2023, NeurIPS23">
<meta name="description" content="by Ev Zisselman, Itai Lavie, Daniel Soudry, and Aviv Tamar">
<meta name="author" content="Arash Alikhani">
<link rel="canonical" href="http://localhost:1313/posts/explore-to-generalize-in-zero-shot-rl/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.a8501b4e1544bf104a4e2647be64df3637f95b6ac25a4298047d87fe0eacffa1.css" integrity="sha256-qFAbThVEvxBKTiZHvmTfNjf5W2rCWkKYBH2H/g6s/6E=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/explore-to-generalize-in-zero-shot-rl/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" integrity="sha384-nB0miv6/jRmo5UMMR1wu3Gz6NLsoTkbqJghGIsx//Rlm+ZU03BU6SQNC66uf4l5+" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js" integrity="sha384-7zkQWkzuo3B5mTepMUcHkMB5jZaolc2xDwL6VFqjFALcbeS9Ggm/Yr2r3Dy4lfFg" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js" integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          
          
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          
          throwOnError : false
        });
    });
</script>
    
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="üß† RL Journal Club (Alt + H)">üß† RL Journal Club</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives" title="üóÉÔ∏è Archive">
                    <span>üóÉÔ∏è Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search" title="üîç Search">
                    <span>üîç Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="üè∑Ô∏è Tags">
                    <span>üè∑Ô∏è Tags</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/us/" title="üë§ Us">
                    <span>üë§ Us</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      ExpGen: Explore to Generalize in Zero-Shot RL
    </h1>
    <div class="post-description">
      by Ev Zisselman, Itai Lavie, Daniel Soudry, and Aviv Tamar
    </div>
    <div class="post-meta"><span title='2024-07-22 00:00:00 +0000 UTC'>July 22, 2024</span>&nbsp;¬∑&nbsp;Arash Alikhani

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#introduction" aria-label="Introduction">Introduction</a></li>
                <li>
                    <a href="#background" aria-label="Background">Background</a><ul>
                        
                <li>
                    <a href="#what-is-reinforcement-learning" aria-label="What is reinforcement learning?">What is reinforcement learning?</a></li>
                <li>
                    <a href="#what-generalization-means-for-rl" aria-label="What generalization means for RL?">What generalization means for RL?</a></li>
                <li>
                    <a href="#what-is-zero-shot-generalization" aria-label="What is zero-shot generalization?">What is zero-shot generalization?</a></li>
                <li>
                    <a href="#what-are-max-reward-and-max-entropy-agents" aria-label="What are max reward and max entropy agents?!">What are max reward and max entropy agents?!</a></li>
                <li>
                    <a href="#what-is-an-ensamble-of-them" aria-label="What is an ensamble of them?!!">What is an ensamble of them?!!</a></li>
                <li>
                    <a href="#what-is-an-invariance-based-approach" aria-label="What is an invariance based approach?">What is an invariance based approach?</a></li>
                <li>
                    <a href="#what-the-heck-is-procgen" aria-label="What the heck is ProcGen?!!!">What the heck is ProcGen?!!!</a></li>
                <li>
                    <a href="#hidden-maze-experiment" aria-label="Hidden Maze Experiment">Hidden Maze Experiment</a></li></ul>
                </li>
                <li>
                    <a href="#maxent-policy" aria-label="MaxEnt Policy">MaxEnt Policy</a></li>
                <li>
                    <a href="#expgen-algorithm" aria-label="ExpGen Algorithm">ExpGen Algorithm</a></li>
                <li>
                    <a href="#experiments" aria-label="Experiments">Experiments</a></li>
                <li>
                    <a href="#see-also" aria-label="See Also">See Also</a></li>
                <li>
                    <a href="#references" aria-label="References">References</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h2>
<p>This paper studies the problem of zero-shot generalization in reinforcement learning and introduces an algorithm that trains an ensamble of maximum reward seeking agents and an maximum entropy agent. At test time, either the ensemble agrees on an action, and we generalize well, or we take exploratory actions with the help of maximum entropy agent and drive us to a novel part of the state space, where the ensemble may potentially agree again. This method combined with an invariance based approach achieves new state-of-the-art results on ProcGen.</p>
<p><img loading="lazy" src="expgen.gif" alt="expgen overview animation"  />
</p>
<h2 id="background">Background<a hidden class="anchor" aria-hidden="true" href="#background">#</a></h2>
<p>I know it&rsquo;s a lot to take in! You may be wondering:</p>
<ul>
<li>What is reinforcement learning? ü•∫</li>
<li>What generalization means for RL? ü•≤</li>
<li>What is zero-shot generalization? ü•π</li>
<li>What are max reward and max entropy agents?! ‚òπÔ∏è</li>
<li>What is an ensamble of them?!! üòü</li>
<li>What is an invariance based approach? üòì</li>
<li>And what the heck is ProcGen?!!! üò†</li>
</ul>
<p>Don&rsquo;t worry! We are going to cover all of that and more! And you are going to fully understand this paper and finish reading this article with an smile üôÇ!</p>
<h3 id="what-is-reinforcement-learning">What is reinforcement learning?<a hidden class="anchor" aria-hidden="true" href="#what-is-reinforcement-learning">#</a></h3>
<p>Reinforcement learning is learning what to do‚Äîhow to map situations to actions‚Äîso as to maximize a numerical reward signal. Imagine yourself right now, in reinforcement learning terms, you are an agent and everything that is not you, is your environment. You perceive the world through your senses (e.g., eyes, ears, etc.) and what you perceive turns into electrical signals that your brain processes to form an understanding of your surroundings (state). Based on this understanding, you make decisions (actions) with the goal of achieving the best possible outcome for yourself (reward).</p>
<p><img loading="lazy" src="rl.png#center" alt="reinforcement learning diagram"  />
</p>
<p>In a more formal sense, reinforcement learning involves the following components:</p>
<ul>
<li><strong>Agent</strong>: The learner or decision maker (e.g., you).</li>
<li><strong>Environment</strong>: Everything the agent interacts with (e.g., the world around you).</li>
<li><strong>State ($s$)</strong>: A representation of the current situation of the agent within the environment (e.g., what you see, hear, and feel at any given moment).</li>
<li><strong>Actions ($a$)</strong>: The set of all possible moves the agent can make (e.g., moving your hand, walking, speaking).</li>
<li><strong>Reward ($r$)</strong>: The feedback received from the environment in response to the agent‚Äôs action (e.g., pleasure from eating food, pain from touching a hot surface).</li>
<li><strong>Policy ($\pi$)</strong>: A strategy used by the agent to decide which actions to take based on the current state (e.g., your habits and decision-making processes).</li>
<li><strong>Value Function ($V$)</strong>: A function that estimates the expected cumulative reward of being in a certain state and following a particular policy (e.g., your prediction of future happiness based on current actions).</li>
</ul>
<p>The objective of the agent is to develop a policy that maximizes the total cumulative reward over time. This is typically achieved through a process of exploration (trying out new actions to discover their effects) and exploitation (using known actions that yield high rewards).</p>
<p>In mathematical terms, the goal is to find a policy $\pi$ that maximizes the expected return $G_t$, which is the cumulative sum of discounted rewards:</p>
<p>$$
G_t = r_{t+1} + \gamma r_{t+2} + \gamma^2 r_{t+3} + \cdots
$$</p>
<p>where $\gamma$ (0 ‚â§ $\gamma$ &lt; 1) is the discount factor that determines the importance of future rewards.</p>
<p>For a more thorough and in depth explanation of reinforcement learning please refer to <a href="https://twitter.com/lilianweng">Lilian Weng</a> excelent blog post <a href="https://lilianweng.github.io/posts/2018-02-19-rl-overview">A (Long) Peek into Reinforcement Learning.</a></p>
<h3 id="what-generalization-means-for-rl">What generalization means for RL?<a hidden class="anchor" aria-hidden="true" href="#what-generalization-means-for-rl">#</a></h3>
<p>In reinforcement learning, generalization involves an agent&rsquo;s ability to apply learned policies or value functions to new states or environments that it has not encountered during training. This is essential because it is often impractical or impossible to train an agent on every possible state it might encounter.</p>
<p>There are bunch of methods that researchers have used to tackle the problem of generalization in reinforcement learning that are summarized in the following diagram.</p>
<p><img loading="lazy" src="gms.png#center" alt="generalization methods in RL"  />
</p>
<p>This paper focuses on RL-Specific solutions and specifically exploration technique to tackle the problem of generalization. If you&rsquo;re interested to learn more about the generalization problem in reinforcement learning please refer to reference [3].</p>
<h3 id="what-is-zero-shot-generalization">What is zero-shot generalization?<a hidden class="anchor" aria-hidden="true" href="#what-is-zero-shot-generalization">#</a></h3>
<p>Zero-shot generalization in RL refers to the ability of an agent to perform well in entirely new environments or tasks without any prior specific training or fine-tuning on those environments or tasks. This is a significant challenge because it requires the agent to leverage its learned representations and policies in a highly flexible and adaptive manner.</p>
<p>In order to define the objective of zero-shot generalization we first have to define what MDPs and POMDPs are.</p>
<p><strong>Markov Decision Process (MDP):</strong></p>
<p>MDP is a mathematical framework used to describe an environment in reinforcement learning where the outcome is partly random and partly under the control of a decision-maker (agent). A MDP is a tuple $M = (S, A, P_{init}, P, r, \gamma)$ where,</p>
<ul>
<li><strong>States ($S \in \mathbb{R}^{|S|}$)</strong>: A finite set of states that describe all possible situations in which the agent can be.</li>
<li><strong>Actions ($A \in \mathbb{R}^{|A|}$)</strong>: A finite set of actions available to the agent.</li>
<li><strong>Initial State Distribution ($P_{init}$)</strong>: A distribution of starting state $(s_0 \sim P_{init})$.</li>
<li><strong>Transition Probability ($P$)</strong>: A function $P(s_{t+1}, s_t, a_t)$ representing the probability of transitioning from state $s_t$ to state $s_{t+1}$ after taking action $a_t$ $(s_{t+1} \sim P(.|s_t,a_t))$.</li>
<li><strong>Reward ($r: S \times A \rightarrow \mathbb{R}$)</strong>: A function $r(s_t, a_t)$ representing the immediate reward $r_t$ received after transitioning from state $s_t$ due to action $a_t$ $(r_t = r(s_t, a_t))$.</li>
<li><strong>Discount Factor ($\gamma$)</strong>: $(0 \leq \gamma &lt; 1)$ is a constant that determines the importance of future rewards.</li>
</ul>
<p><strong>Partially Observable Markov Decision Process (POMDP):</strong></p>
<p>POMDP extends MDPs to situations where the agent does not have complete information about the current state. Instead, the agent must make decisions based on partial observations. A POMDP is a tuple $M = (S, A, O, P_{init}, P, \Sigma, r, \gamma)$ where other that above definitions for MDP,</p>
<ul>
<li><strong>Observation Space ($O$)</strong>: A finite set of observations the agent can receive about the state.</li>
<li><strong>Observation Function ($\Sigma$)</strong>: A function that given current state $s_t$ and current action $a_t$ gives us the current observation $o_t$ $(o_t = \Sigma(s_t, a_t) \in O)$.</li>
</ul>
<p>If we set $O = S$ and $\Sigma(s,a) = s$, the POMDP turns into regular MDP.</p>
<p>Let the history at time $t$ be,</p>
<p>$$
h_t = \{ o_0, a_0, r_0, o_1, a_1, r_1, \dots, o_t \}
$$</p>
<p>The agent‚Äôs next action is outlined by a policy $\pi$, which is a stochastic mapping from the history to an action probability,</p>
<p>$$
\pi(a|h_t) = P(a_t=a|h_t)
$$</p>
<p>In this formulation, a history-dependent policy (and not a Markov policy) is required both due to partially observed states, epistemic uncertainty, and also for optimal maxEnt exploration.</p>
<p>We assume a prior distribution over POMDPs $P(M)$, defined over some space of POMDPs. For a given POMDP, an optimal policy maximizes the expected discounted return,</p>
<p>$$
\mathbb{E}_{\pi,M} \left[ \sum _{t=0}^{\infty} \gamma^t r(s_t,a_t) \right]
$$</p>
<p>Where the expectation is taken over the policy $\pi(h_t)$, and the state transition probability $s_t \sim P$ of POMDP $M$.</p>
<p>Our generalization objective is to maximize the discounted cumulative reward taken in expectation over the POMDP prior,</p>
<p>$$
\mathcal{R}_ {pop}(\pi) = \mathbb{E}_ {M \sim P(M)} {\left[ \mathbb{E}_{\pi,M} {\left[ \sum _{t=0}^{\infty} \gamma^t r(s_t,a_t) \right]} \right]}
$$</p>
<p>Seeking a policy that performs well in expectation over any POMDP from the prior corresponds to zero-shot generalization.</p>
<p>And as you may have guessed we don&rsquo;t have access to true prior distribution of POMDPs so we have to estimate it with $N$ training POMDPs $M_1, M_2, \dots, M_N$ sampled from the true prior distribution $P(M)$. So we are going to maximize empirical discounted cumulative reward,</p>
<p>$$
\begin{align*}
\mathcal{R}_ {emp}(\pi) &amp;= \frac{1}{N} \sum _ {i=1}^{N} \mathbb{E} _ {\pi,M_i} \left[ \sum _ {t=0}^{\infty} \gamma^t r(s_t,a_t) \right]
\\
&amp;= \mathbb{E}_ {M \sim \hat{P}(M)} {\left[ \mathbb{E}_{\pi,M} {\left[ \sum _{t=0}^{\infty} \gamma^t r(s_t,a_t) \right]} \right]}
\end{align*}
$$</p>
<p>Where the empirical POMDP distribution $\hat{P}(M)$ can be different from the true distribution, i.e. $\hat{P}(M) \neq P(M)$. In general, a policy that optimizes the empirical reward may perform poorly on the population reward and this is known as overfitting in statistical learning theory.</p>
<h3 id="what-are-max-reward-and-max-entropy-agents">What are max reward and max entropy agents?!<a hidden class="anchor" aria-hidden="true" href="#what-are-max-reward-and-max-entropy-agents">#</a></h3>
<p>As we have seen, the goal of agents in reinforcement learning is to find a policy $\pi$ that maximizes the expected discounted return by focusing on actions that lead to the greatest immediate or future rewards. We call these common RL agents &ldquo;max reward agents&rdquo; in this paper. On the other hand, &ldquo;max entropy agents&rdquo; aim to maximize the entropy of the policy for visiting different states. Maximizing entropy encourages the agent to explore a wider range of actions that lead the agent to visit new states even when they don&rsquo;t contribute any reward.</p>
<p>This type of agent will help us to make decisions when we have epistemic uncertainty about what to do at test time. Epistemic uncertainty basically means the uncertainty that we have because of our lack of knowledge and can be improved by gathering more information about the situation.</p>
<p>The insight of the authors of this paper is that learning a policy that effectively explores the domain is harder to memorize than a policy that maximizes reward for a specific task, and therefore they expect such learned behavior to generalize well.</p>
<h3 id="what-is-an-ensamble-of-them">What is an ensamble of them?!!<a hidden class="anchor" aria-hidden="true" href="#what-is-an-ensamble-of-them">#</a></h3>
<p>Ensembling in reinforcement learning involves combining the policies of multiple individual agents to make more accurate and robust decisions. The idea is that by aggregating the outputs of different agents, we can leverage their diverse perspectives and expertise to improve overall performance.</p>
<p>This paper uses an ensamble of max reward agents to help the agent decide on the overal epistemic uncetainty that we have at test time.</p>
<h3 id="what-is-an-invariance-based-approach">What is an invariance based approach?<a hidden class="anchor" aria-hidden="true" href="#what-is-an-invariance-based-approach">#</a></h3>
<p>Invariance based algorithms in reinforcement learning focus on developing policies that are robust to changes and variations in the environment. These algorithms aim to identify and leverage invariant features or patterns that remain consistent across different environments or tasks. The goal is to ensure that the learned policy performs well not just in the training environment but also in new, unseen environments.</p>
<p>This paper uses IDAAC algorithm which is a special kind of DAAC algorithm as its invariance based algorithm.</p>
<p>DAAC (Decoupled Advantage Actor-Critic) uses two separate networks, one for learning the policy and advantage, and one for learning the value. The value estimates are used to compute the advantage targets.</p>
<p>IDAAC (Invariant Decoupled Advantage Actor-Critic) adds an additional regularizer to the DAAC policy encoder to ensure that it does not contain episode-specific information. The encoder is trained adversarially with a discriminator so that it cannot classify which observation from a given pair $(s_i, s_j)$ was first in a trajectory.</p>
<p><img loading="lazy" src="idaac.png#center" alt="Invariant Decoupled Advantage Actor-Critic"  />
</p>
<p>For more information about IDAAC algorithm please refer to reference [4].</p>
<h3 id="what-the-heck-is-procgen">What the heck is ProcGen?!!!<a hidden class="anchor" aria-hidden="true" href="#what-the-heck-is-procgen">#</a></h3>
<p><a href="https://github.com/openai/procgen">Procgen</a> is a benchmark suite for evaluating the generalization capabilities of reinforcement learning agents. It was developed by OpenAI and consists of a collection of procedurally generated environments that vary in terms of visual appearance, dynamics, and difficulty. The goal of Procgen is to provide a standardized and challenging set of environments that can be used to assess the ability of RL algorithms to generalize to unseen scenarios.</p>
<p><img loading="lazy" src="procgen.gif#center" alt="Procgen"  />
</p>
<p>If you are new to reinforcement learning, I know these explanations are a lot to take in! If you find yourself lost, I recommend to check out the following courses at your leisure:</p>
<ul>
<li><a href="https://huggingface.co/learn/deep-rl-course">Deep Reinforcement Learning (by Hugging Face ü§ó)</a></li>
<li><a href="https://www.youtube.com/playlist?list=PLzvYlJMoZ02Dxtwe-MmH4nOB5jYlMGBjr">Reinforcement Learning (by Mutual Information)</a></li>
<li><a href="https://www.youtube.com/playlist?list=PLqYmG7hTraZDM-OYHWgPebj2MfCFzFObQ">Introduction to Reinforcement Learning (by David Silver)</a></li>
<li><a href="https://edstem.org/us/join/TUNxMk">Reinforcement Learning (by Michael Littman &amp; Charles Isbell)</a></li>
<li><a href="https://www.youtube.com/playlist?list=PLoROMvodv4rOSOPzutgyCTapiGlY2Nd8u">Reinforcement Learning (by Emma Brunskill)</a></li>
<li><a href="https://sites.google.com/view/deep-rl-bootcamp/home">Deep Reinforcement Learning Bootcamp 2017</a></li>
<li><a href="https://www.youtube.com/playlist?list=PLwRJQ4m4UJjNymuBM9RdmB3Z9N5-0IlY0">Foundations of Deep RL (by Pieter Abbeel)</a></li>
<li><a href="https://scs.hosted.panopto.com/Panopto/Pages/Sessions/List.aspx#folderID=%22ee5794a2-cb54-4edc-836b-aefc01023243%22&amp;view=2&amp;sortColumn=1&amp;sortAscending=true&amp;page=0&amp;maxResults=50">Deep Reinforcement Learning &amp; Control (by Katerina Fragkiadaki)</a></li>
<li><a href="https://www.youtube.com/playlist?list=PL_iWQOsE6TfVYGEGiAOMaOzzv41Jfm_Ps">Deep Reinforcement Learning (by Sergey Levine)</a></li>
</ul>
<p>After reviewing all this we can focus on the rest of the paper!</p>
<h3 id="hidden-maze-experiment">Hidden Maze Experiment<a hidden class="anchor" aria-hidden="true" href="#hidden-maze-experiment">#</a></h3>
<p>One of the key observation of the authors of this paper is that invariance is not enough for zero-shot generalization of reinforcemen learning algorithm. They designed the hidden maze experiment too demonstrate that. Imagine Maze, but with the walls and goal hidden in the observation. Arguably, this is the most task-invariant observation possible, such that a solution can still be obtained in a reasonable time.</p>
<p><img loading="lazy" src="hmaze.png#center" alt="Hidden Maze Experiment"  />
</p>
<p>An agent with memory can be trained to optimally solve all training tasks: figuring out wall positions by trying to move ahead and observing the resulting motion, and identifying based on its movement history in which training maze it is currently in. Obviously, such a strategy will not generalize to test mazes. Performance in Maze, where the strategy for solving any particular training task must be indicative of that task, has largely not improved by methods based on invariance</p>
<p>The following figure shows PPO performance on the hidden maze task, indicating severe overfitting.</p>
<p><img loading="lazy" src="hmazer.png#center" alt="Hidden Maze Experiment Result"  />
</p>
<p>As described by [5], an agent can overcome test-time errors in its policy by treating the perfect policy as an unobserved variable. The resulting decision making problem, termed the epistemic POMDP, may require some exploration at test time to resolve uncertainty. The article further proposed the LEEP algorithm based on this principle, which trains an ensemble of agents and essentially chooses randomly between the members when the ensemble does not agree, and was the first method to present substantial generalization improvement on Maze.</p>
<p>In this paper authors extend this idea and asked, How to improve exploration at test time?, and their approach is based on a novel discovery, when they train an agent to explore the training domains using a maximum entropy objective, they observe that the learned exploration behavior generalizes surprisingly well (much better than the generalization attained when training the agent to maximize reward).</p>
<p>In the following section we gonna dig deep into internals of maximum entropy policy.</p>
<h2 id="maxent-policy">MaxEnt Policy<a hidden class="anchor" aria-hidden="true" href="#maxent-policy">#</a></h2>
<p>For simplicity the authors discuss this part for the MDP case. A policy $\pi$, through its interaction with an MDP, induces a t-step state distribution over the state space $S$,</p>
<p>$$
d _ {t,\pi} (s) = p(s_t=s | \pi)
$$</p>
<p>The objective of maximum entropy exploration is given by:</p>
<p>$$
\mathcal{H}(d(.)) = -\mathbb{E} _ {s \sim d} \left[ \log{d(s)} \right]
$$</p>
<p>Where $d$ can be regarded as either,</p>
<ul>
<li>Stationary state distribution (infinite horizon): $d _ {\pi} = \lim _ {t \rightarrow \infty} d _ {t,\pi} (s)$</li>
<li>Discounted state distribution (infinite horizon): $d _ {\gamma, \pi} = (1-\gamma) \sum _ {t=0} ^ {\infty} \gamma^t d _ {t,\pi} (s)$</li>
<li>Marginal state distribution (finite horizon): $d _ {T, \pi} = \frac{1}{T} \sum _ {t=0} ^ {T} d _ {t,\pi} (s)$</li>
</ul>
<p>In this work they focus on the finite horizon setting and adapt the marginal state distribution $d _ {T, \pi}$ in which $T$ equals the episode horizon $H$, so we seek to maximize the objective:</p>
<p>$$
\begin{align*}
\mathcal{R} _ {\mathcal{H}} (\pi)
&amp;= \mathbb{E} _ {M \sim \hat{P}(M)} \left[ \mathcal{H}(d _ {H,\pi}) \right] \\
&amp;=\mathbb{E} _ {M \sim \hat{P}(M)} \left[ \mathcal{H}(\frac{1}{H} \sum _ {t=0} ^ {H} d _ {t,\pi} (s)) \right]
\end{align*}
$$</p>
<p>which yields a policy that &ldquo;equally&rdquo; visits all states during the episode.</p>
<p>To maximize this objective we can estimating the density of the agent&rsquo;s state visitation distribution, but in this paper the authors adapt the non-parametric entropy estimation approach; we estimate the entropy using the particle based k-nearest neighbor (k-NN estimator).</p>
<p>To estimate the distribution $d _ {H,\pi}$ over the states $S$, we consider each trajectory as $H$ samples of states $\{ s_t \} _ {t=1} ^ {H}$ and take $s _ t ^ {\text{k-NN}}$ to be the k-NN of the state $s_t$ within the trajectory,</p>
<p>$$
\hat{ \mathcal{H} } ^ {k,H} (d _ {H,\pi}) \approx \frac{1}{H} \sum _ {t=1} ^ {H} \log ( \parallel s_t - s_t^{\text{k-NN}} \parallel _ 2)
$$</p>
<p>In which we define intrinsic reward function as,</p>
<p>$$
r_I (s_t) \coloneqq \log ( \parallel s_t - s_t^{\text{k-NN}} \parallel _ 2)
$$</p>
<p>This formulation enables us to deploy any RL algorithm to approximately optimize objective.</p>
<p>Specifically, in this work we use the policy gradient algorithm PPOŸà where at every time step $t$, the state $s_t^{\text{k-NN}}$ is chosen from previous states $\{ s_t \} _ {t=1} ^ {t-1}$ of the same episode. To improve computational efficiency, instead of taking the full observation as the state (64 x 64 RGB image), we sub-sample the observation by applying average pooling of 3 x 3 to produce an image of size 21 x 21.</p>
<p>We found that agents trained for maximum entropy exploration exhibit a smaller generalization gap compared with the standard approach of training solely with extrinsic reward. The policies are equipped with a memory unit (GRU) to allow learning of deterministic policies that maximize the entropy.</p>
<p>In all three environments, we demonstrate a small generalization gap, as test performance on unseen levels closely follows the performance achieved during training.</p>
<p><img loading="lazy" src="mxentgen.png#center" alt="Generalization of maxEnt Policy"  />
</p>
<p>In addition, we verify that the train results are near optimal by comparing with a hand designed approximately optimal exploration policy. For example, on Maze we use the well known maze exploring strategy wall follower, also known as the left/right-hand rule.</p>
<h2 id="expgen-algorithm">ExpGen Algorithm<a hidden class="anchor" aria-hidden="true" href="#expgen-algorithm">#</a></h2>
<p>Our main insight is that, given the generalization property of the entropy maximization policy established above, an agent can apply this behavior in a test MDP and expect effective exploration at test time. We pair this insight with the epistemic POMDP idea, and propose to play the exploration policy when the agent faces epistemic uncertainty, hopefully driving the agent to a different state where the reward-seeking policy is more certain.</p>
<p>Our framework comprises two parts: an entropy maximizing network and an ensemble of networks that maximize an extrinsic reward to evaluate epistemic uncertainty. The first step entails training a network equipped with a memory unit to obtain a maxEnt policy $\pi_H$ that maximizes entropy. Next, we train an ensemble of memory-less policy networks $\{ \pi _ r ^ j \} _ {j=1} ^ {m} $ to maximize extrinsic reward.</p>
<p>Here is the ExpGen algorithm,</p>
<p><img loading="lazy" src="expgen.png#center" alt="ExpGen Algorithm"  />
</p>
<p>We consider domains with a finite action space, and say that the policy $\pi _ r ^ i$ is certain at state $s$ if its action $a_i \sim \pi _ r ^ i (a|s)$ is in consensus with the ensemble: $a_i = a_j$ for the majority of $k$ out of $m$, where $k$ is a hyperparameter of our algorithm.</p>
<p><img loading="lazy" src="maze.gif#center" alt="ExpGen Algorithm In Action"  />
</p>
<p>Switching between two policies may result in a case where the agent repeatedly toggles between two states (if, say, the maxEnt policy takes the agent from state $s_1$ to a state $s_2$, where the ensemble agrees on an action that again moves to state $s_1$.). To avoid such ‚Äúmeta-stable‚Äù behavior, we randomly choose the number of maxEnt steps $n_{\pi_{\mathcal{H}}}$ from a Geometric distribution, $n_{\pi_{\mathcal{H}}} \sim Geom(\alpha)$.</p>
<h2 id="experiments">Experiments<a hidden class="anchor" aria-hidden="true" href="#experiments">#</a></h2>
<p>Our experimental setup follows ProcGen&rsquo;s easy configuration, wherein agents are trained on 200 levels for 25M steps and subsequently tested on random levels. All agents are implemented using the IMPALA (Importance Weighted Actor-Learner Architectures) convolutional architecture, and trained using PPO or IDAAC. For the maximum entropy agent $\pi_H$ we incorporate a single GRU at the final embedding of the IMPALA convolutional architecture. For all games, we use the same parameter $\alpha=0.5$ of the Geometric distribution and form an ensemble of 10 networks.</p>
<p><img loading="lazy" src="impala.png#center" alt="IMPALA"  />
</p>
<p>Following figure is comparison across all ProcGen games, with 95% bootstrap CIs highlighted in color. Score distributions of ExpGen, PPO, PLR, UCB-DrAC, PPG and IDAAC.</p>
<p><img loading="lazy" src="comp1.png#center" alt="Result Comparison"  />
</p>
<p>Following figure shows in each row, the probability of algorithm X outperforming algorithm Y. The comparison illustrates the superiority of ExpGen over the leading contender IDAAC with probability 0.6, as well as over other methods with even higher probability.</p>
<p><img loading="lazy" src="comp2.png#center" alt="Result Comparison"  />
</p>
<h2 id="see-also">See Also<a hidden class="anchor" aria-hidden="true" href="#see-also">#</a></h2>
<ul>
<li><a href="https://github.com/EvZissel/expgen">PyTorch implementation of ExpGen @ GitHub</a></li>
<li><a href="https://slideslive.com/39015036">Ev Zisselman Presentation @ NeurIPS 2023</a></li>
<li><a href="https://openreview.net/forum?id=37cADkATD0">ExpGen Rebuttal Process @ OpenReview</a></li>
<li><a href="https://neurips.cc/media/PosterPDFs/NeurIPS%202023/79886.png">ExpGen Poster for NeurIPS 2023</a></li>
</ul>
<h2 id="references">References<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h2>
<p>[1] <a href="https://arxiv.org/abs/2306.03072">Zisselman, Ev, et al. &ldquo;Explore to generalize in zero-shot rl.&rdquo; Advances in Neural Information Processing Systems 36 (2024).</a></p>
<p>[2] <a href="http://incompleteideas.net/book/the-book-2nd.html">Sutton, Richard S., and Andrew G. Barto. &ldquo;Reinforcement learning: An introduction.&rdquo; MIT press, (2020).</a></p>
<p>[3] <a href="https://www.jair.org/index.php/jair/article/view/14174">Kirk, Robert, et al. &ldquo;A survey of zero-shot generalisation in deep reinforcement learning.&rdquo; Journal of Artificial Intelligence Research 76 (2023): 201-264.</a></p>
<p>[4] <a href="https://arxiv.org/abs/2102.10330">Raileanu, Roberta, and Rob Fergus. &ldquo;Decoupling value and policy for generalization in reinforcement learning.&rdquo; International Conference on Machine Learning. PMLR, 2021.</a></p>
<p>[5] <a href="https://proceedings.neurips.cc/paper/2021/hash/d5ff135377d39f1de7372c95c74dd962-Abstract.html">Ghosh, Dibya, et al. &ldquo;Why generalization in rl is difficult: Epistemic pomdps and implicit partial observability.&rdquo; Advances in neural information processing systems 34 (2021): 25502-25515.</a></p>
<p>[6] <a href="https://arxiv.org/abs/1802.01561">Espeholt, Lasse, et al. &ldquo;Impala: Scalable distributed deep-rl with importance weighted actor-learner architectures.&rdquo; International conference on machine learning. PMLR, 2018.</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/exploration/">Exploration</a></li>
      <li><a href="http://localhost:1313/tags/generalization/">Generalization</a></li>
      <li><a href="http://localhost:1313/tags/zero-shot/">Zero-Shot</a></li>
      <li><a href="http://localhost:1313/tags/ensemble/">Ensemble</a></li>
      <li><a href="http://localhost:1313/tags/entropy/">Entropy</a></li>
      <li><a href="http://localhost:1313/tags/impala/">IMPALA</a></li>
      <li><a href="http://localhost:1313/tags/ppo/">PPO</a></li>
      <li><a href="http://localhost:1313/tags/idaac/">IDAAC</a></li>
      <li><a href="http://localhost:1313/tags/procgen/">Procgen</a></li>
      <li><a href="http://localhost:1313/tags/neurips/">NeurIPS</a></li>
      <li><a href="http://localhost:1313/tags/2023/">2023</a></li>
      <li><a href="http://localhost:1313/tags/neurips23/">NeurIPS23</a></li>
    </ul>
  </footer>
</article>

<div id="disqus_thread"></div>
<script>
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "rljclub-github-io" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">üß† RL Journal Club</a></span> ¬∑ 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
